            
            // Exibir indicador de carregamento
// Componente principal para a se√ß√£o de Ranking de RUNES

class RunesRanking {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        if (!this.container) {
            console.error(`Container com ID "${containerId}" n√£o encontrado.`);
            return;
        }
        
        this.runesData = [];
        this.currentMetric = 'volume24h';
        this.sortOrder = 'desc';
        this.sentimentColors = {
            positive: 'linear-gradient(90deg, #2ecc71, #27ae60)',
            neutral: 'linear-gradient(90deg, #f39c12, #f1c40f)',
            negative: 'linear-gradient(90deg, #e74c3c, #c0392b)'
        };
        
        this.initializeUI();
		 // Carregar dados reais via servi√ßo
        this.loadRealData() {
    console.log("Carregando dados reais...");
    // Fallback para dados mockup por enquanto
    this.loadMockData();
}
    
    // Verificar se o servi√ßo est√° dispon√≠vel globalmente
    if (window.RunesDataService) {
        window.RunesDataService.getRuneStats()
            .then(data => {
                if (data) {
                    this.runesData = data;
                    this.updateRanking();
                } else {
                    this.loadMockData();
                }
            })
            .catch(error => {
                console.error('Erro ao carregar dados:', error);
                this.loadMockData();
            });
    } else {
        console.warn('RunesDataService n√£o dispon√≠vel');
        this.loadMockData();
    }
}
		

    
    // Remover event listeners para evitar memory leaks
    const metricSelect = document.getElementById('metric-select');
    const sortAscBtn = document.getElementById('sort-asc');
    const sortDescBtn = document.getElementById('sort-desc');
    const tableViewBtn = document.getElementById('table-view');
    const gridViewBtn = document.getElementById('grid-view');
    
    if (metricSelect) metricSelect.removeEventListener('change', this.handleMetricChange);
    if (sortAscBtn) sortAscBtn.removeEventListener('click', this.handleSortAsc);
    if (sortDescBtn) sortDescBtn.removeEventListener('click', this.handleSortDesc);
    if (tableViewBtn) tableViewBtn.removeEventListener('click', this.handleTableView);
    if (gridViewBtn) gridViewBtn.removeEventListener('click', this.handleGridView);
    
    // Limpar quaisquer timers ou WebSockets
    if (this.realtimeInterval) {
        clearInterval(this.realtimeInterval);
        this.realtimeInterval = null;
    }
}

    initializeUI() {
        console.log('Inicializando UI da se√ß√£o de Ranking de RUNES');
        
        // Criar estrutura base do componente
        this.container.innerHTML = `
            <div class="section-intro">
                <h3>Ranking de RUNES</h3>
                <p>RUNES s√£o tokens fung√≠veis baseados em Bitcoin L1 com caracter√≠sticas √∫nicas de efici√™ncia e escalabilidade.</p>
            </div>
            
            <div class="ranking-controls">
                <div class="metric-selector">
                    <label for="metric-select">Ordenar por:</label>
                    <select id="metric-select" class="select-styled">
                        <option value="volume24h">Volume 24h</option>
                        <option value="priceChange24h">Varia√ß√£o de Pre√ßo 24h</option>
                        <option value="holdersCount">N√∫mero de Holders</option>
                        <option value="marketCap">Capitaliza√ß√£o de Mercado</option>
                        <option value="sentiment">Sentimento</option>
                    </select>
                </div>
                
                <div class="sort-direction">
                    <button id="sort-asc" class="sort-btn" title="Ordem crescente">‚Üë</button>
                    <button id="sort-desc" class="sort-btn active" title="Ordem decrescente">‚Üì</button>
                </div>
                
                <div class="view-options">
                    <button id="table-view" class="view-btn active"><i class="fas fa-table"></i> Tabela</button>
                    <button id="grid-view" class="view-btn"><i class="fas fa-th"></i> Cards</button>
                </div>
            </div>
            
            <div id="ranking-table-container" class="ranking-table-container"></div>
        `;
        
        try {
            // Adicionar event listeners
            this.setupEventListeners();
            
            // Carregar dados
            this.loadMockData();
			// Configurar atualiza√ß√µes em tempo real
setupRealtimeUpdates() {
    console.log('Configurando atualiza√ß√µes em tempo real...');
    
    // Armazenar refer√™ncia ao intervalo para limpeza posterior
    this.realtimeInterval = setInterval(() => {
        // Selecionar um item aleat√≥rio para atualizar
        const randomIndex = Math.floor(Math.random() * this.runesData.length);
        const rune = this.runesData[randomIndex];
        
        // Gerar uma mudan√ßa de pre√ßo aleat√≥ria (entre -2% e +2%)
        const priceChange = (Math.random() * 4 - 2) / 100;
        const oldPrice = rune.price;
        const newPrice = oldPrice * (1 + priceChange);
        
        // Atualizar o pre√ßo e a varia√ß√£o
        rune.price = newPrice;
        rune.priceChange24h = parseFloat((rune.priceChange24h + (priceChange * 100)).toFixed(2));
        
        console.log(`Atualiza√ß√£o em tempo real: ${rune.ticker} - Pre√ßo: ${this.formatPrice(oldPrice)} -> ${this.formatPrice(newPrice)}`);
        
        // Destacar visualmente na UI
        this.highlightPriceChange(rune.ticker, priceChange >= 0);
        
        // Se estiver ordenado por pre√ßo, reordenar a tabela
        if (this.currentMetric === 'price' || this.currentMetric === 'priceChange24h') {
            this.updateRanking();
        } else {
            // Caso contr√°rio, apenas atualizar c√©lula espec√≠fica
            this.updatePriceCell(rune.ticker, newPrice, rune.priceChange24h);
        }
        
    }, 5000 + Math.random() * 5000); // Interval entre 5 e 10 segundos
}

// Destacar visualmente uma mudan√ßa de pre√ßo
highlightPriceChange(ticker, isPositive) {
    const rows = document.querySelectorAll('.data-table tbody tr');
    
    rows.forEach(row => {
        const tickerCell = row.querySelector('.rune-ticker');
        if (tickerCell && tickerCell.textContent === ticker) {
            const priceCell = row.querySelector('td:nth-child(3)');
            const changeCell = row.querySelector('td:nth-child(4)');
            
            if (priceCell && changeCell) {
                // Adicionar classe para anima√ß√£o
                const highlightClass = isPositive ? 'highlight-positive' : 'highlight-negative';
                
                priceCell.classList.add(highlightClass);
                changeCell.classList.add(highlightClass);
                
                // Remover classe ap√≥s a anima√ß√£o
                setTimeout(() => {
                    priceCell.classList.remove(highlightClass);
                    changeCell.classList.remove(highlightClass);
                }, 1000);
            }
        }
    });
}

// Atualizar apenas uma c√©lula de pre√ßo sem reordenar toda a tabela
updatePriceCell(ticker, newPrice, priceChange) {
    const rows = document.querySelectorAll('.data-table tbody tr');
    
    rows.forEach(row => {
        const tickerCell = row.querySelector('.rune-ticker');
        if (tickerCell && tickerCell.textContent === ticker) {
            const priceCell = row.querySelector('td:nth-child(3)');
            const changeCell = row.querySelector('td:nth-child(4)');
            
            if (priceCell && changeCell) {
                priceCell.textContent = this.formatPrice(newPrice);
                
                const changeClass = priceChange >= 0 ? 'positive' : 'negative';
                const formattedChange = (priceChange >= 0 ? '+' : '') + priceChange.toFixed(2) + '%';
                
                changeCell.textContent = formattedChange;
                changeCell.className = changeClass;
            }
        }
    });
}() {
    try {
        console.log('Buscando dados reais de RUNES via RunesDataService...');
        
        // Exibir indicador de carregamento
        this.showLoading(true);
        
        // Buscar dados atrav√©s do servi√ßo
        const runesRanking = await runesDataService.getRunesRanking();
        
        if (runesRanking && runesRanking.length > 0) {
            this.runesData = runesRanking;
            
            // Registrar para receber atualiza√ß√µes em tempo real
            runesDataService.onPriceUpdate(this.handlePriceUpdate.bind(this));
            
            // Atualizar a exibi√ß√£o
            this.updateRanking();
            console.log(`Dados de ${runesRanking.length} RUNES carregados com sucesso`);
        } else {
            console.warn('Servi√ßo retornou um conjunto de dados vazio, usando fallback.');
            this.loadMockData();
			loadRealData() {
    console.log('Buscando dados reais de RUNES...');
    
    // Exibir indicador de carregamento
    this.showLoading(true);
    
    // Simula√ß√£o tempor√°ria de chamada de API com timeout
    setTimeout(() => {
        try {
            // Dados simulados com fonte de dados
            const apiData = [
                { 
                    ticker: 'BAR‚Ä¢BITCOIN‚Ä¢TOKEN', 
                    symbol: 'üç∫', 
                    price: 0.0031, 
                    priceChange24h: 15.82, 
                    volume24h: 187500000, 
                    holdersCount: 121400, 
                    sentiment: 92, 
                    marketCap: 313750000,
                    dataSource: 'bestInSlot'
                },
                { 
                    ticker: 'RUNES‚Ä¢DEV‚Ä¢DAO', 
                    symbol: 'üë®‚Äçüíª', 
                    price: 0.0024, 
                    priceChange24h: -3.41, 
                    volume24h: 76300000, 
                    holdersCount: 38200, 
                    sentiment: 68, 
                    marketCap: 47180000,
                    dataSource: 'magicEden'
                },
                { 
                    ticker: 'BITCOIN‚Ä¢PIZZA‚Ä¢DAY', 
                    symbol: 'üçï', 
                    price: 0.0096, 
                    priceChange24h: 28.12, 
                    volume24h: 42600000, 
                    holdersCount: 31650, 
                    sentiment: 84, 
                    marketCap: 168320000,
                    dataSource: 'okx'
                }
            ];
            
            // Manter alguns dados mockados originais
            const originalData = this.getMockData();
            
            // Combinar dados da "API" com alguns dados mockados
            this.runesData = [...apiData, ...originalData];
            
            // Atualizar a UI
            this.updateRanking();
            
            // Configurar atualiza√ß√µes em tempo real
            this.setupRealtimeUpdates();
            
        } catch (error) {
            console.error('Erro ao processar dados:', error);
            this.loadMockData(); // Fallback para dados mockados
        } finally {
            // Esconder indicador de carregamento
            this.showLoading(false);
        }
    }, 1500); // Simula√ß√£o de delay de rede
}

// M√©todo auxiliar para obter alguns dados mockados originais
getMockData() {
    return [
        { 
            ticker: 'DOG‚Ä¢GO‚Ä¢TO‚Ä¢THE‚Ä¢MOON', 
            symbol: 'üêï', 
            price: 0.0017, 
            priceChange24h: 2.01, 
            volume24h: 105100000, 
            holdersCount: 97900, 
            sentiment: 85, 
            marketCap: 173090000,
            dataSource: 'mock' 
        },
        { 
            ticker: 'MAGIC‚Ä¢INTERNET‚Ä¢MONEY', 
            symbol: 'üí∞', 
            price: 0.0013, 
            priceChange24h: 37.51, 
            volume24h: 26000000, 
            holdersCount: 40600, 
            sentiment: 78, 
            marketCap: 31030000,
            dataSource: 'mock' 
        }
    ];
}
        
     catch (error) {
        console.error('Erro ao buscar dados reais de RUNES:', error);
        // Fallback para dados mockados em caso de erro
        this.loadMockData();
    } finally {
        // Esconder indicador de carregamento
        this.showLoading(false);
    }
}

// Handler para atualiza√ß√µes de pre√ßo em tempo real
handlePriceUpdate(updatedRune) {
    console.log(`Recebida atualiza√ß√£o para ${updatedRune.ticker}: ${this.formatPrice(updatedRune.price)}`);
    
    // Encontrar a RUNE nos dados atuais
    const runeIndex = this.runesData.findIndex(rune => rune.ticker === updatedRune.ticker);
    
    if (runeIndex >= 0) {
        // Obter o pre√ßo antigo para compara√ß√£o
        const oldPrice = this.runesData[runeIndex].price;
        const priceIncreased = updatedRune.price > oldPrice;
        
        // Atualizar os dados
        this.runesData[runeIndex] = {
            ...this.runesData[runeIndex],
            price: updatedRune.price,
            priceChange24h: updatedRune.priceChange24h,
            volume24h: updatedRune.volume24h || this.runesData[runeIndex].volume24h,
            lastUpdate: new Date().toISOString()
        };
        
        // Destacar visualmente a mudan√ßa
        this.highlightPriceChange(updatedRune.ticker, priceIncreased);
        
        // Se estiver ordenado por pre√ßo ou varia√ß√£o, reordenar a tabela
        if (this.currentMetric === 'price' || this.currentMetric === 'priceChange24h') {
            this.updateRanking();
        } else {
            // Caso contr√°rio, apenas atualizar c√©lula espec√≠fica
            this.updatePriceCell(updatedRune.ticker, updatedRune.price, updatedRune.priceChange24h);
        }
    }
            
        } catch (error) {
            console.error('Erro ao inicializar componentes:', error);
            this.showError('N√£o foi poss√≠vel inicializar os componentes de ranking.');
        }
    }
    
    setupEventListeners() {
        // Event listener para sele√ß√£o de m√©trica
        const metricSelect = document.getElementById('metric-select');
        if (metricSelect) {
            metricSelect.addEventListener('change', (e) => {
                this.currentMetric = e.target.value;
                this.updateRanking();
            });
        }
        
        // Event listeners para bot√µes de ordena√ß√£o
        const sortAscBtn = document.getElementById('sort-asc');
        const sortDescBtn = document.getElementById('sort-desc');
        
        if (sortAscBtn && sortDescBtn) {
            sortAscBtn.addEventListener('click', () => {
                sortAscBtn.classList.add('active');
                sortDescBtn.classList.remove('active');
                this.sortOrder = 'asc';
                this.updateRanking();
            });
            
            sortDescBtn.addEventListener('click', () => {
                sortDescBtn.classList.add('active');
                sortAscBtn.classList.remove('active');
                this.sortOrder = 'desc';
                this.updateRanking();
            });
        }
        
        // Event listeners para bot√µes de visualiza√ß√£o
        const tableViewBtn = document.getElementById('table-view');
        const gridViewBtn = document.getElementById('grid-view');
        
        if (tableViewBtn && gridViewBtn) {
            tableViewBtn.addEventListener('click', () => {
                tableViewBtn.classList.add('active');
                gridViewBtn.classList.remove('active');
                this.updateViewMode('table');
            });
            
            gridViewBtn.addEventListener('click', () => {
                gridViewBtn.classList.add('active');
                tableViewBtn.classList.remove('active');
                this.updateViewMode('grid');
            });
        }
    }
    
    loadMockData() {
        console.log('Carregando dados mockup para RUNES');
        
        // Dados mockup para testes
        const mockData = [
            { 
                ticker: 'DOG‚Ä¢GO‚Ä¢TO‚Ä¢THE‚Ä¢MOON', 
                symbol: 'üêï', 
                price: 0.0017, 
                priceChange24h: 2.01, 
                volume24h: 105100000, 
                holdersCount: 97900, 
                sentiment: 85, 
                marketCap: 173090000 
            },
            { 
                ticker: 'MAGIC‚Ä¢INTERNET‚Ä¢MONEY', 
                symbol: 'üí∞', 
                price: 0.0013, 
                priceChange24h: 37.51, 
                volume24h: 26000000, 
                holdersCount: 40600, 
                sentiment: 78, 
                marketCap: 31030000 
            },
            { 
                ticker: 'NIKOLA‚Ä¢TESLA‚Ä¢GOD', 
                symbol: '‚ö°', 
                price: 0.016, 
                priceChange24h: 0.55, 
                volume24h: 12500000, 
                holdersCount: 56300, 
                sentiment: 62, 
                marketCap: 16270000 
            },
            { 
                ticker: 'CYPHER‚Ä¢GENESIS', 
                symbol: 'üîê', 
                price: 0.0012, 
                priceChange24h: 53.46, 
                volume24h: 2700000, 
                holdersCount: 57200, 
                sentiment: 79, 
                marketCap: 1260000 
            },
            { 
                ticker: 'BILLION‚Ä¢DOLLAR‚Ä¢CAT', 
                symbol: 'üê±', 
                price: 0.0082, 
                priceChange24h: 0.96, 
                volume24h: 7400000, 
                holdersCount: 15100, 
                sentiment: 71, 
                marketCap: 8950000 
            },
            { 
                ticker: 'GCM‚Ä¢BITCOIN‚Ä¢PARTNER', 
                symbol: 'ü§ù', 
                price: 4.2, 
                priceChange24h: 3.14, 
                volume24h: 2600000, 
                holdersCount: 13900, 
                sentiment: 65, 
                marketCap: 88530000 
            },
            { 
                ticker: 'PUPS‚Ä¢WORLD‚Ä¢PEACE', 
                symbol: 'üê∂', 
                price: 0.02, 
                priceChange24h: -0.24, 
                volume24h: 3900000, 
                holdersCount: 13000, 
                sentiment: 69, 
                marketCap: 20760000 
            },
            { 
                ticker: 'CRAZY‚Ä¢THURSDAY', 
                symbol: 'üóìÔ∏è', 
                price: 0.41, 
                priceChange24h: 6.3, 
                volume24h: 1100000, 
                holdersCount: 6600, 
                sentiment: 77, 
                marketCap: 8760000 
            },
            { 
                ticker: 'RSIC‚Ä¢GENESIS‚Ä¢RUNE', 
                symbol: 'üîÑ', 
                price: 0.00059, 
                priceChange24h: -7.44, 
                volume24h: 2900000, 
                holdersCount: 98200, 
                sentiment: 58, 
                marketCap: 12940000 
            },
            { 
                ticker: 'MEMENTO‚Ä¢MORI', 
                symbol: '‚è≥', 
                price: 0.017, 
                priceChange24h: 1.39, 
                volume24h: 4100000, 
                holdersCount: 8100, 
                sentiment: 64, 
                marketCap: 1780000 
            }
        ];
        
        this.runesData = mockData;
        // Adicione este m√©todo ap√≥s o loadMockData()
async loadRealData() {
    try {
        console.log('Buscando dados reais de RUNES...');
        
		// Exibir indicador de carregamento
 showLoading(isLoading) {
    const container = document.getElementById('ranking-table-container');
    if (!container) return;
    
    if (isLoading) {
        // Criar e mostrar o indicador de carregamento
        const loadingEl = document.createElement('div');
        loadingEl.className = 'loading-indicator';
        loadingEl.innerHTML = `
            <div class="spinner"></div>
            <p>Carregando dados das APIs...</p>
        `;
        container.innerHTML = '';
        container.appendChild(loadingEl);
    }
}
        
        // Por enquanto, usamos uma simula√ß√£o de chamada de API
        // No futuro, substituiremos por API real
        setTimeout(() => {
            // Dados simulados vindos de uma API
            const apiData = [
                { 
                    ticker: 'BAR‚Ä¢BITCOIN‚Ä¢TOKEN', 
                    symbol: 'üç∫', 
                    price: 0.0031, 
                    priceChange24h: 15.82, 
                    volume24h: 187500000, 
                    holdersCount: 121400, 
                    sentiment: 92, 
                    marketCap: 313750000 
                },
                { 
                    ticker: 'RUNES‚Ä¢DEV‚Ä¢DAO', 
                    symbol: 'üë®‚Äçüíª', 
                    price: 0.0024, 
                    priceChange24h: -3.41, 
                    volume24h: 76300000, 
                    holdersCount: 38200, 
                    sentiment: 68, 
                    marketCap: 47180000 
                },
                { 
                    ticker: 'BITCOIN‚Ä¢PIZZA‚Ä¢DAY', 
                    symbol: 'üçï', 
                    price: 0.0096, 
                    priceChange24h: 28.12, 
                    volume24h: 42600000, 
                    holdersCount: 31650, 
                    sentiment: 84, 
                    marketCap: 168320000 
                },
                // Mantenha os dados mockados originais tamb√©m
                ...this.getMockData()
            ];
            
            this.runesData = apiData;
            this.updateRanking();
            this.showLoading(false);
        }, 1500); // Atraso de 1.5s para simular o tempo de resposta da API
        
    } catch (error) {
        console.error('Erro ao buscar dados reais:', error);
        // Fallback para dados mockados em caso de erro
        this.loadMockData();
        this.showLoading(false);
    }
}

// M√©todo auxiliar para devolver os dados mock originais
getMockData() {
    return [
        { 
            ticker: 'DOG‚Ä¢GO‚Ä¢TO‚Ä¢THE‚Ä¢MOON', 
            symbol: 'üêï', 
            price: 0.0017, 
            priceChange24h: 2.01, 
            volume24h: 105100000, 
            holdersCount: 97900, 
            sentiment: 85, 
            marketCap: 173090000 
        },
        { 
            ticker: 'MAGIC‚Ä¢INTERNET‚Ä¢MONEY', 
            symbol: 'üí∞', 
            price: 0.0013, 
            priceChange24h: 37.51, 
            volume24h: 26000000, 
            holdersCount: 40600, 
            sentiment: 78, 
            marketCap: 31030000 
        },
        { 
            ticker: 'NIKOLA‚Ä¢TESLA‚Ä¢GOD', 
            symbol: '‚ö°', 
            price: 0.016, 
            priceChange24h: 0.55, 
            volume24h: 12500000, 
            holdersCount: 56300, 
            sentiment: 62, 
            marketCap: 16270000 
        }
    ];
}
        this.updateRanking();
    }
    
    updateRanking() {
        // Verificar se o container existe
        renderGridView(container) {
    // Limpar o container
    container.innerHTML = '';
    
    // Ordenar os dados
    const sortedData = this.sortItems(this.runesData, this.currentMetric, this.sortOrder);
    
    // Criar o wrapper do grid
    const gridWrapper = document.createElement('div');
    gridWrapper.className = 'runes-grid';
    
    sortedData.forEach((rune, index) => {
        // Formatar dados
        const changeClass = rune.priceChange24h >= 0 ? 'positive' : 'negative';
        const formattedPrice = this.formatPrice(rune.price);
        const priceChange = (rune.priceChange24h >= 0 ? '+' : '') + rune.priceChange24h.toFixed(2) + '%';
        
        // Criar card
        const card = document.createElement('div');
        card.className = 'rune-card';
        
        // Adicionar fonte de dados se dispon√≠vel
        // Vers√£o corrigida:
        const dataSourceTag = rune.dataSource ? 
        `<div class="data-source-tag">${rune.dataSource}</div>` : '';
    
         card.innerHTML = `...
            <div class="rune-card-header">
                <div class="rune-card-rank">#${index + 1}</div>
                <div class="rune-card-symbol">${rune.symbol || 'ü™ô'}</div>
                <div class="rune-card-info">
                    <h3>${rune.ticker}</h3>
                    <div class="price-container">
                        <span class="price">${formattedPrice}</span>
                        <span class="price-change ${changeClass}">${priceChange}</span>
                    </div>
                </div>
                ${dataSourceTag}
            </div>
            <div class="rune-card-details">
                <div class="detail-row">
                    <div class="detail-label">Volume 24h</div>
                    <div class="detail-value">$${this.formatNumber(rune.volume24h, true)}</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">Market Cap</div>
                    <div class="detail-value">$${this.formatNumber(rune.marketCap, true)}</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">Holders</div>
                    <div class="detail-value">${this.formatNumber(rune.holdersCount)}</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">Sentimento</div>
                    <div class="detail-value">
                        <div class="sentiment-meter small">
                            <div class="sentiment-bar" style="width: ${rune.sentiment}%;"></div>
                            <span>${rune.sentiment}</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        gridWrapper.appendChild(card);
    });
    
    container.appendChild(gridWrapper);
    
    // Adicionar nota sobre dados
    const noteDiv = document.createElement('div');
    noteDiv.className = 'data-note';
    noteDiv.innerHTML = `
        <p><i>Dados baseados em plataformas de RUNES como Magic Eden, BestInSlot e OKX. √öltima atualiza√ß√£o: ${new Date().toLocaleTimeString()}</i></p>
    `;
    container.appendChild(noteDiv);
}
        // Adicionar nota sobre dados
        const noteDiv = document.createElement('div');
        noteDiv.className = 'data-note';
        noteDiv.innerHTML = `
            <p><i>Dados baseados em plataformas de RUNES como Magic Eden, BestInSlot e OKX.</i></p>
        `;
        tableContainer.appendChild(noteDiv);
    }
    
    updateViewMode(mode) {
        // Alternar entre exibi√ß√£o de tabela e grid
        const container = document.getElementById('ranking-table-container');
        if (!container) return;
        
        if (mode === 'grid') {
            // Renderizar visualiza√ß√£o em cards
            this.renderGridView(container);
        } else {
            // Renderizar visualiza√ß√£o em tabela
            this.updateRanking();
        }
    }
    
    renderGridView(container) {
        // Limpar o container
        container.innerHTML = '';
        
        // Ordenar os dados
        const sortedData = this.sortItems(this.runesData, this.currentMetric, this.sortOrder);
        
        // Criar o wrapper do grid
        const gridWrapper = document.createElement('div');
        gridWrapper.className = 'runes-grid';
        
        sortedData.forEach((rune, index) => {
            // Formatar dados
            const changeClass = rune.priceChange24h >= 0 ? 'positive' : 'negative';
            const formattedPrice = this.formatPrice(rune.price);
            const priceChange = (rune.priceChange24h >= 0 ? '+' : '') + rune.priceChange24h.toFixed(2) + '%';
            
            // Criar card
            const card = document.createElement('div');
            card.className = 'rune-card';
            
            card.innerHTML = `
                <div class="rune-card-header">
                    <div class="rune-card-rank">#${index + 1}</div>
                    <div class="rune-card-symbol">${rune.symbol || 'ü™ô'}</div>
                    <div class="rune-card-info">
                        <h3>${rune.ticker}</h3>
                        <div class="price-container">
                            <span class="price">${formattedPrice}</span>
                            <span class="price-change ${changeClass}">${priceChange}</span>
                        </div>
                    </div>
                </div>
                <div class="rune-card-details">
                    <div class="detail-row">
                        <div class="detail-label">Volume 24h</div>
                        <div class="detail-value">$${this.formatNumber(rune.volume24h, true)}</div>
                    </div>
                    <div class="detail-row">
                        <div class="detail-label">Market Cap</div>
                        <div class="detail-value">$${this.formatNumber(rune.marketCap, true)}</div>
                    </div>
                    <div class="detail-row">
                        <div class="detail-label">Holders</div>
                        <div class="detail-value">${this.formatNumber(rune.holdersCount)}</div>
                    </div>
                    <div class="detail-row">
                        <div class="detail-label">Sentimento</div>
                        <div class="detail-value">
                            <div class="sentiment-meter small">
                                <div class="sentiment-bar" style="width: ${rune.sentiment}%;"></div>
                                <span>${rune.sentiment}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            gridWrapper.appendChild(card);
        });
        
        container.appendChild(gridWrapper);
        
        // Adicionar nota sobre dados
        const noteDiv = document.createElement('div');
        noteDiv.className = 'data-note';
        noteDiv.innerHTML = `
            <p><i>Dados baseados em plataformas de RUNES como Magic Eden, BestInSlot e OKX.</i></p>
        `;
        container.appendChild(noteDiv);
    }
    
    // M√©todos auxiliares
    sortItems(data, metric, order) {
        return [...data].sort((a, b) => {
            let valueA = a[metric] || 0;
            let valueB = b[metric] || 0;
            
            // Converter para n√∫mero se for string
            if (typeof valueA === 'string') valueA = parseFloat(valueA) || 0;
            if (typeof valueB === 'string') valueB = parseFloat(valueB) || 0;
            
            return order === 'asc' ? valueA - valueB : valueB - valueA;
        });
    }
    
// Substitua a fun√ß√£o de formata√ß√£o de pre√ßo atual por esta:
formatPrice(price) {
    if (!price) return '0.00 sats';
    
    const numPrice = typeof price === 'string' ? parseFloat(price) : price;
    
    // Converter para satoshis (1 BTC = 100,000,000 sats)
    const satPrice = numPrice < 1 ? numPrice : numPrice * 100000000;
    
    if (satPrice < 0.01) return satPrice.toExponential(2) + ' sats';
    if (satPrice < 1) return satPrice.toFixed(5) + ' sats';
    if (satPrice < 10) return satPrice.toFixed(4) + ' sats';
    if (satPrice < 100) return satPrice.toFixed(3) + ' sats';
    if (satPrice < 1000) return satPrice.toFixed(2) + ' sats';
    return Math.round(satPrice) + ' sats';
}
    
    formatNumber(num, abbreviated = false) {
        if (abbreviated) {
            if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
            return num.toFixed(0);
        }
        
        return new Intl.NumberFormat().format(num);
    }
    
    showError(message) {
        const container = this.container;
        if (container) {
            container.innerHTML = `
                <div class="error-message">
                    <div class="error-icon">‚ö†Ô∏è</div>
                    <h3>Erro ao carregar ranking</h3>
                    <p>${message}</p>
                </div>
            `;
			showLoading(isLoading) {
    const container = document.getElementById('ranking-table-container');
    if (!container) return;
    
    if (isLoading) {
        // Criar e mostrar o indicador de carregamento
        const loadingEl = document.createElement('div');
        loadingEl.className = 'loading-indicator';
        loadingEl.innerHTML = `
            <div class="spinner"></div>
            <p>Carregando dados das APIs...</p>
        `;
        container.innerHTML = '';
        container.appendChild(loadingEl);
        }
    }
	setupRealtimeUpdates() {
    // Simula√ß√£o de atualiza√ß√µes em tempo real
    console.log('Configurando atualiza√ß√µes em tempo real...');
    
    // Armazenar refer√™ncia ao interval para poder limpar depois
    this.realtimeInterval = setInterval(() => {
        // Apenas para demonstra√ß√£o: atualiza um item aleat√≥rio a cada 5-10 segundos
        const randomIndex = Math.floor(Math.random() * this.runesData.length);
        const rune = this.runesData[randomIndex];
        
        // Gerar uma mudan√ßa de pre√ßo aleat√≥ria (entre -2% e +2%)
        const priceChange = (Math.random() * 4 - 2) / 100;
        const oldPrice = rune.price;
        const newPrice = oldPrice * (1 + priceChange);
        
        // Atualizar o pre√ßo e a varia√ß√£o
        rune.price = newPrice;
        rune.priceChange24h = rune.priceChange24h + (priceChange * 100);
        
        // Atualizar timestamp da √∫ltima atualiza√ß√£o
        rune.lastUpdate = new Date().toISOString();
        
        console.log(`Atualiza√ß√£o em tempo real: ${rune.ticker} - Pre√ßo: ${this.formatPrice(oldPrice)} -> ${this.formatPrice(newPrice)}`);
        
        // Destaque visual na UI
        this.highlightPriceChange(rune.ticker, priceChange >= 0);
        
        // Se estiver ordenado por pre√ßo, reordenar a tabela
        if (this.currentMetric === 'price' || this.currentMetric === 'priceChange24h') {
            this.updateRanking();
        } else {
            // Caso contr√°rio, apenas atualizar c√©lula espec√≠fica
            this.updatePriceCell(rune.ticker, newPrice, rune.priceChange24h);
        } // Destacar visualmente uma mudan√ßa de pre√ßo
highlightPriceChange(ticker, isPositive) {
    const rows = document.querySelectorAll('.data-table tbody tr');
    
    rows.forEach(row => {
        const tickerCell = row.querySelector('.rune-ticker');
        if (tickerCell && tickerCell.textContent === ticker) {
            const priceCell = row.querySelector('td:nth-child(3)');
            const changeCell = row.querySelector('td:nth-child(4)');
            
            if (priceCell && changeCell) {
                // Adicionar classe para anima√ß√£o
                const highlightClass = isPositive ? 'highlight-positive' : 'highlight-negative';
                
                priceCell.classList.add(highlightClass);
                changeCell.classList.add(highlightClass);
                
                // Remover classe ap√≥s a anima√ß√£o
                setTimeout(() => {
                    priceCell.classList.remove(highlightClass);
                    changeCell.classList.remove(highlightClass);
                }, 1000);
            }
        }
    });
}

// Atualizar apenas uma c√©lula de pre√ßo sem reordenar toda a tabela
updatePriceCell(ticker, newPrice, priceChange) {
    const rows = document.querySelectorAll('.data-table tbody tr');
    
    rows.forEach(row => {
        const tickerCell = row.querySelector('.rune-ticker');
        if (tickerCell && tickerCell.textContent === ticker) {
            const priceCell = row.querySelector('td:nth-child(3)');
            const changeCell = row.querySelector('td:nth-child(4)');
            
            if (priceCell && changeCell) {
                priceCell.textContent = this.formatPrice(newPrice);
                
                const changeClass = priceChange >= 0 ? 'positive' : 'negative';
                const formattedChange = (priceChange >= 0 ? '+' : '') + priceChange.toFixed(2) + '%';
                
                changeCell.textContent = formattedChange;
                changeCell.className = changeClass;
            }
        }
    });
}

// Exibir indicador de carregamento
showLoading(isLoading) {
    const container = document.getElementById('ranking-table-container');
    if (!container) return;
    
    if (isLoading) {
        // Criar e mostrar o indicador de carregamento
        const loadingEl = document.createElement('div');
        loadingEl.className = 'loading-indicator';
        loadingEl.innerHTML = `
            <div class="spinner"></div>
            <p>Carregando dados das APIs...</p>
        `;
        container.innerHTML = '';
        container.appendChild(loadingEl);
    }
}
        
    }, 5000 + Math.random() * 5000); // Interval entre 5 e 10 segundos
}

// Destacar visualmente uma mudan√ßa de pre√ßo
highlightPriceChange(ticker, isPositive) {
    const rows = document.querySelectorAll('.data-table tbody tr');
    
    rows.forEach(row => {
        const tickerCell = row.querySelector('.rune-ticker');
        if (tickerCell && tickerCell.textContent === ticker) {
            const priceCell = row.querySelector('td:nth-child(3)');
            const changeCell = row.querySelector('td:nth-child(4)');
            
            if (priceCell && changeCell) {
                // Adicionar classe para anima√ß√£o
                const highlightClass = isPositive ? 'highlight-positive' : 'highlight-negative';
                
                priceCell.classList.add(highlightClass);
                changeCell.classList.add(highlightClass);
                
                // Remover classe ap√≥s a anima√ß√£o
                setTimeout(() => {
                    priceCell.classList.remove(highlightClass);
                    changeCell.classList.remove(highlightClass);
                }, 1000);
            }
        }
    });
}

// Atualizar apenas uma c√©lula de pre√ßo sem reordenar toda a tabela
updatePriceCell(ticker, newPrice, priceChange) {
    const rows = document.querySelectorAll('.data-table tbody tr');
    
    rows.forEach(row => {
        const tickerCell = row.querySelector('.rune-ticker');
        if (tickerCell && tickerCell.textContent === ticker) {
            const priceCell = row.querySelector('td:nth-child(3)');
            const changeCell = row.querySelector('td:nth-child(4)');
            
            if (priceCell && changeCell) {
                priceCell.textContent = this.formatPrice(newPrice);
                
                const changeClass = priceChange >= 0 ? 'positive' : 'negative';
                const formattedChange = (priceChange >= 0 ? '+' : '') + priceChange.toFixed(2) + '%';
                
                changeCell.textContent = formattedChange;
                changeCell.className = changeClass;
            }
        }
    });
}

// Inicializar o componente quando o documento estiver carregado
document.addEventListener('DOMContentLoaded', function() {
    const rankingSection = document.getElementById('ranking');
    const rankingContainer = document.getElementById('ranking-container');
    
    if (rankingContainer) {
        const rankingComponent = new RunesRanking('ranking-container');
        console.log('Componente de ranking inicializado com sucesso');
    }
});