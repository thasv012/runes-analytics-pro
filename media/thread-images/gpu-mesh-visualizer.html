<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GPU Mesh Visualizer - RUNES Analytics Pro</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      text-align: center;
      padding: 2rem;
      pointer-events: none;
    }
    
    h1 {
      font-size: 3rem;
      margin-bottom: 1rem;
      text-shadow: 0 0 10px rgba(0, 128, 255, 0.8);
    }
    
    p {
      font-size: 1.5rem;
      max-width: 800px;
      margin: 0.5rem 0;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
    }
    
    .stats {
      display: flex;
      gap: 2rem;
      margin-top: 2rem;
    }
    
    .stat {
      background-color: rgba(0, 0, 0, 0.6);
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid rgba(0, 128, 255, 0.3);
    }
    
    .stat-value {
      font-size: 2.5rem;
      font-weight: bold;
      color: #58a6ff;
    }
    
    .stat-label {
      font-size: 1rem;
      opacity: 0.8;
    }
    
    .controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      gap: 10px;
      pointer-events: auto;
    }
    
    button {
      background-color: rgba(0, 128, 255, 0.3);
      color: white;
      border: 1px solid rgba(0, 128, 255, 0.5);
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    
    button:hover {
      background-color: rgba(0, 128, 255, 0.5);
    }
    
    .node-tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(0, 128, 255, 0.5);
      color: white;
      padding: 10px;
      border-radius: 4px;
      font-size: 14px;
      pointer-events: none;
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="overlay">
    <h1>GPU Mesh Network</h1>
    <p>Processamento distribuído em 8 nós ativos garantindo performance superior nas análises</p>
    
    <div class="stats">
      <div class="stat">
        <div class="stat-value">8</div>
        <div class="stat-label">Nós GPU Ativos</div>
      </div>
      <div class="stat">
        <div class="stat-value">1.2s</div>
        <div class="stat-label">Latência Média</div>
      </div>
      <div class="stat">
        <div class="stat-value">78%</div>
        <div class="stat-label">Redução de Latência</div>
      </div>
    </div>
  </div>
  
  <div class="controls">
    <button id="download-btn">Capturar Imagem</button>
    <button id="toggle-animation">Pausar Animação</button>
  </div>
  
  <div class="node-tooltip" id="tooltip"></div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const tooltip = document.getElementById('tooltip');
      const downloadBtn = document.getElementById('download-btn');
      const toggleAnimationBtn = document.getElementById('toggle-animation');
      
      // Configurações
      let animationRunning = true;
      const nodeCount = 8;
      const edgeCount = 12;
      const nodeRadius = 20;
      const animationSpeed = 0.005;
      
      // Cores
      const colors = {
        background: '#000428',
        node: {
          fill: '#1f6feb',
          stroke: '#58a6ff',
          active: '#56d364',
          hover: '#ffa657'
        },
        edge: {
          stroke: 'rgba(88, 166, 255, 0.2)',
          data: 'rgba(88, 166, 255, 0.8)',
          active: 'rgba(86, 211, 100, 0.8)'
        }
      };
      
      // Redimensiona o canvas
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // Nós e arestas
      const nodes = [];
      const edges = [];
      let hoveredNode = null;
      let dataPackets = [];
      
      // Inicializa os nós
      function initNodes() {
        nodes.length = 0;
        
        // Nó central (coordenador)
        nodes.push({
          id: 'coordinator',
          x: canvas.width / 2,
          y: canvas.height / 2,
          radius: nodeRadius * 1.5,
          color: colors.node.fill,
          type: 'coordinator',
          label: 'Coordenador',
          load: 0.7,
          connections: 0
        });
        
        // Nós GPU
        for (let i = 0; i < nodeCount - 1; i++) {
          const angle = (Math.PI * 2 * i) / (nodeCount - 1);
          const distance = Math.min(canvas.width, canvas.height) * 0.3;
          
          nodes.push({
            id: `gpu-${i + 1}`,
            x: canvas.width / 2 + Math.cos(angle) * distance,
            y: canvas.height / 2 + Math.sin(angle) * distance,
            radius: nodeRadius,
            color: colors.node.fill,
            type: 'gpu',
            label: `GPU ${i + 1}`,
            load: Math.random(),
            connections: 0
          });
        }
      }
      
      // Inicializa as arestas
      function initEdges() {
        edges.length = 0;
        
        // Conecta o coordenador a todos os nós GPU
        for (let i = 1; i < nodes.length; i++) {
          edges.push({
            from: 0,
            to: i,
            active: false,
            trafficLoad: Math.random(),
            pulseOffset: Math.random() * Math.PI * 2
          });
          
          nodes[0].connections++;
          nodes[i].connections++;
        }
        
        // Adiciona conexões entre nós GPU
        let edgesAdded = nodes.length - 1;
        while (edgesAdded < edgeCount && edgesAdded < (nodes.length * (nodes.length - 1)) / 2) {
          const from = 1 + Math.floor(Math.random() * (nodes.length - 1));
          const to = 1 + Math.floor(Math.random() * (nodes.length - 1));
          
          if (from !== to && !edges.some(e => 
            (e.from === from && e.to === to) || 
            (e.from === to && e.to === from)
          )) {
            edges.push({
              from: from,
              to: to,
              active: false,
              trafficLoad: Math.random() * 0.5,
              pulseOffset: Math.random() * Math.PI * 2
            });
            
            nodes[from].connections++;
            nodes[to].connections++;
            edgesAdded++;
          }
        }
      }
      
      // Desenha um nó
      function drawNode(node, isHovered = false) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        
        // Cor de preenchimento baseada no tipo e carga
        let fillColor = node.color;
        if (isHovered) {
          fillColor = colors.node.hover;
        } else if (node.type === 'coordinator') {
          fillColor = colors.node.fill;
        } else {
          // Cor baseada na carga (verde para baixa, amarelo para média, vermelho para alta)
          const loadColor = hslToRgb(0.3 - node.load * 0.3, 0.8, 0.5);
          fillColor = `rgb(${loadColor[0]}, ${loadColor[1]}, ${loadColor[2]})`;
        }
        
        ctx.fillStyle = fillColor;
        ctx.fill();
        
        // Borda
        ctx.lineWidth = 2;
        ctx.strokeStyle = isHovered ? colors.node.hover : colors.node.stroke;
        ctx.stroke();
        
        // Pulso de atividade
        const time = performance.now() * 0.001;
        const pulse = Math.sin(time * 2) * 0.5 + 0.5;
        
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius + 5 * pulse, 0, Math.PI * 2);
        ctx.lineWidth = 1;
        ctx.strokeStyle = `rgba(88, 166, 255, ${0.2 * pulse})`;
        ctx.stroke();
        
        // Rótulo do nó
        ctx.fillStyle = 'white';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.label, node.x, node.y);
      }
      
      // Desenha uma aresta
      function drawEdge(edge) {
        const fromNode = nodes[edge.from];
        const toNode = nodes[edge.to];
        
        // Linha base
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.lineWidth = 1 + edge.trafficLoad * 3;
        ctx.strokeStyle = edge.active ? colors.edge.active : colors.edge.stroke;
        ctx.stroke();
        
        // Efeito de pulso na linha
        const time = performance.now() * 0.001;
        const pulse = Math.sin(time * 2 + edge.pulseOffset) * 0.5 + 0.5;
        
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.lineWidth = 1;
        ctx.strokeStyle = `rgba(88, 166, 255, ${0.2 * pulse})`;
        ctx.stroke();
      }
      
      // Cria pacotes de dados
      function createDataPacket() {
        if (dataPackets.length > 30) return; // Limita o número de pacotes
        
        // Escolhe uma aresta aleatória
        const edgeIndex = Math.floor(Math.random() * edges.length);
        const edge = edges[edgeIndex];
        
        // Escolhe direção (avante ou reverso)
        const forward = Math.random() > 0.5;
        const fromNode = nodes[forward ? edge.from : edge.to];
        const toNode = nodes[forward ? edge.to : edge.from];
        
        dataPackets.push({
          edge: edgeIndex,
          progress: 0,
          speed: 0.005 + Math.random() * 0.01,
          color: Math.random() > 0.7 ? colors.edge.active : colors.edge.data,
          fromNode: fromNode,
          toNode: toNode,
          size: 3 + Math.random() * 4
        });
        
        // Marca a aresta como ativa
        edge.active = true;
        
        // Programa a desativação após 1-2 segundos
        setTimeout(() => {
          edge.active = false;
        }, 1000 + Math.random() * 1000);
      }
      
      // Atualiza pacotes de dados
      function updateDataPackets() {
        for (let i = dataPackets.length - 1; i >= 0; i--) {
          const packet = dataPackets[i];
          packet.progress += packet.speed;
          
          if (packet.progress >= 1) {
            dataPackets.splice(i, 1);
          }
        }
        
        // Cria novos pacotes periodicamente
        if (Math.random() < 0.05) {
          createDataPacket();
        }
      }
      
      // Desenha pacotes de dados
      function drawDataPackets() {
        dataPackets.forEach(packet => {
          const x = packet.fromNode.x + (packet.toNode.x - packet.fromNode.x) * packet.progress;
          const y = packet.fromNode.y + (packet.toNode.y - packet.fromNode.y) * packet.progress;
          
          ctx.beginPath();
          ctx.arc(x, y, packet.size, 0, Math.PI * 2);
          ctx.fillStyle = packet.color;
          ctx.fill();
        });
      }
      
      // Loop de animação
      function animate() {
        if (!animationRunning) {
          requestAnimationFrame(animate);
          return;
        }
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Desenha fundo com gradiente
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#000428');
        gradient.addColorStop(1, '#004e92');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Atualiza posições dos nós com animação suave
        const time = performance.now() * animationSpeed;
        nodes.forEach((node, index) => {
          if (index !== 0) { // Não mover o nó coordenador
            node.x += Math.sin(time + index * 0.5) * 0.5;
            node.y += Math.cos(time + index * 0.5) * 0.5;
          }
        });
        
        // Desenha arestas
        edges.forEach(drawEdge);
        
        // Atualiza e desenha pacotes de dados
        updateDataPackets();
        drawDataPackets();
        
        // Desenha nós
        nodes.forEach((node, index) => {
          drawNode(node, index === hoveredNode);
        });
        
        requestAnimationFrame(animate);
      }
      
      // Manipulador de movimento do mouse
      canvas.addEventListener('mousemove', function(event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        
        // Verifica se o mouse está sobre algum nó
        let found = false;
        nodes.forEach((node, index) => {
          const distance = Math.sqrt(
            Math.pow(mouseX - node.x, 2) + 
            Math.pow(mouseY - node.y, 2)
          );
          
          if (distance <= node.radius) {
            hoveredNode = index;
            found = true;
            
            // Exibe tooltip
            tooltip.style.display = 'block';
            tooltip.style.left = `${event.clientX + 10}px`;
            tooltip.style.top = `${event.clientY + 10}px`;
            tooltip.innerHTML = `
              <strong>${node.label}</strong><br>
              Tipo: ${node.type === 'coordinator' ? 'Coordenador' : 'GPU Worker'}<br>
              Carga: ${Math.round(node.load * 100)}%<br>
              Conexões: ${node.connections}
            `;
          }
        });
        
        if (!found) {
          hoveredNode = null;
          tooltip.style.display = 'none';
        }
      });
      
      // Evento de clique do mouse
      canvas.addEventListener('click', function(event) {
        if (hoveredNode !== null) {
          const node = nodes[hoveredNode];
          
          // Simula tráfego a partir do nó clicado
          edges.forEach((edge, index) => {
            if (edge.from === hoveredNode || edge.to === hoveredNode) {
              const fromNode = nodes[edge.from];
              const toNode = nodes[edge.to];
              
              // Cria pacotes de dados
              for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                  dataPackets.push({
                    edge: index,
                    progress: 0,
                    speed: 0.005 + Math.random() * 0.01,
                    color: colors.edge.active,
                    fromNode: hoveredNode === edge.from ? fromNode : toNode,
                    toNode: hoveredNode === edge.from ? toNode : fromNode,
                    size: 3 + Math.random() * 4
                  });
                }, i * 200);
              }
              
              // Marca a aresta como ativa
              edge.active = true;
              
              // Programa a desativação
              setTimeout(() => {
                edge.active = false;
              }, 1500);
            }
          });
        }
      });
      
      // Download da imagem
      downloadBtn.addEventListener('click', function() {
        // Cria um canvas temporário com dimensões fixas para output
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 1200;
        tempCanvas.height = 675;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Desenha o conteúdo atual ajustado para o tamanho do canvas temporário
        const scaleX = tempCanvas.width / canvas.width;
        const scaleY = tempCanvas.height / canvas.height;
        tempCtx.scale(scaleX, scaleY);
        
        // Fundo
        const gradient = tempCtx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#000428');
        gradient.addColorStop(1, '#004e92');
        tempCtx.fillStyle = gradient;
        tempCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Desenha arestas
        edges.forEach(drawEdge.bind(tempCtx));
        
        // Desenha pacotes de dados
        drawDataPackets.bind(tempCtx)();
        
        // Desenha nós
        nodes.forEach(node => drawNode.bind(tempCtx)(node, false));
        
        // Adiciona título e subtítulo
        tempCtx.scale(1/scaleX, 1/scaleY); // Reseta a escala
        
        tempCtx.fillStyle = 'white';
        tempCtx.font = 'bold 48px sans-serif';
        tempCtx.textAlign = 'center';
        tempCtx.fillText('GPU Mesh Network', tempCanvas.width / 2, 80);
        
        tempCtx.font = '24px sans-serif';
        tempCtx.fillText('Processamento distribuído em 8 nós ativos', tempCanvas.width / 2, 130);
        
        // Adiciona estatísticas
        const stats = [
          { value: '8', label: 'Nós GPU Ativos' },
          { value: '1.2s', label: 'Latência Média' },
          { value: '78%', label: 'Redução de Latência' }
        ];
        
        const statWidth = 180;
        const statX = (tempCanvas.width - (stats.length * statWidth + (stats.length - 1) * 20)) / 2;
        
        stats.forEach((stat, i) => {
          const x = statX + i * (statWidth + 20);
          const y = tempCanvas.height - 120;
          
          // Fundo do stat
          tempCtx.fillStyle = 'rgba(0, 0, 0, 0.6)';
          tempCtx.fillRect(x, y, statWidth, 80);
          tempCtx.strokeStyle = 'rgba(0, 128, 255, 0.3)';
          tempCtx.lineWidth = 1;
          tempCtx.strokeRect(x, y, statWidth, 80);
          
          // Valor
          tempCtx.fillStyle = '#58a6ff';
          tempCtx.font = 'bold 36px sans-serif';
          tempCtx.textAlign = 'center';
          tempCtx.fillText(stat.value, x + statWidth/2, y + 30);
          
          // Rótulo
          tempCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          tempCtx.font = '16px sans-serif';
          tempCtx.fillText(stat.label, x + statWidth/2, y + 60);
        });
        
        // Adiciona marca d'água
        tempCtx.font = '18px sans-serif';
        tempCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        tempCtx.textAlign = 'right';
        tempCtx.fillText('RUNES Analytics Pro', tempCanvas.width - 30, tempCanvas.height - 20);
        
        // Cria link para download
        const link = document.createElement('a');
        link.href = tempCanvas.toDataURL('image/png');
        link.download = 'runes-analytics-thread-gpu-mesh.png';
        link.click();
      });
      
      // Toggle animação
      toggleAnimationBtn.addEventListener('click', function() {
        animationRunning = !animationRunning;
        this.textContent = animationRunning ? 'Pausar Animação' : 'Retomar Animação';
      });
      
      // Função auxiliar: HSL para RGB
      function hslToRgb(h, s, l) {
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        return [
          Math.round(r * 255),
          Math.round(g * 255),
          Math.round(b * 255)
        ];
      }
      
      // Inicializa e inicia animação
      initNodes();
      initEdges();
      animate();
    });
  </script>
</body>
</html> 